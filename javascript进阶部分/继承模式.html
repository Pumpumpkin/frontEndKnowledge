<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
<script type="text/javascrip">
//prototype原型模式
function Animal(species){
	this.species = species;
	this.eat = function(food){
		alert("吃" + food);
	}
}
function Dog(){
    
}
// Dog.prototype = new Animal();
var hashiqi = new Dog();
</script>

<script type="text/javascrip">
	function Cat(){

	}
	Cat.prototype.age = "12";
	var cat1 = new Cat();
	console.log(cat1.constructor === Cat.prototype.constructor);
	console.log(cat1.__proto__ ===Cat.prototype);
	console.log(Cat.prototype.__proto__);
</script>

 <script type="text/javascript">
 //原型继承之圣杯模式
 //实现A继承B

//使用Inherit函数把需要继承的原型对象封装起来，显得更模块化，整齐，不乱;
function Inherit(Target,Origin){
  function F(){};// 定义一个中间函数，通过其生产的对象继承Origin.prototype
  F.prototype = Origin.prototype;
  Target.prototype = new F();//Target.prototype保存的是F函数生产的对象的引用，直接指向的是F的实例对象
  //这样,给目标函数的原型对象添加属性和方法不会影响到原始函数的原型对象,而且还可以继承原始函数的原型对象的属性和方法
  Target.prototype.constructor = Target;//使得目标构造函数的cosntructor指向目标构造函数
  Target.prototype.uber = Origin.prototype;
  //通过.uber这个属性来访问目标函数的原型对象到底是继承自谁的(原始函数的原型对象)
}

function Eat(age){
	console.log("I am eating");
	// this.name = name;
	this.age = age;
}
// Eat.prototype --- > new F()-- __proto__ --- F.prototype = {}
function Run(){
	console.log("I am running");
}
Run.prototype = {
    distance : '18km',
    speed : '5km'
}
Inherit(Eat,Run);
var person1 = new Eat(121);
//注意:第41行和42行不可换,因为换了的话,Eat.prototype指向的空间是new F(),此时通过new F ()的__proto__指向F.prototype = {},后面执行F.prototype = Origin.prototype已经晚了,尽管这时的F.prototype保存了Origin.prototype的引用，指向了一个新的空间(Origin.prototype),但是这时Target.protope指向的是原来的F.prototype(注意，这里赋值保存的是引用值)
 </script>

</body>
</html>