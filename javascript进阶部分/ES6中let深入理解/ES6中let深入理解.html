<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600587 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="387"/>

<div>
<span><div>在es6的语法中,新增了let命令来声明一个变量,该变量只在let命令所在的代码快内有效</div><div>更深入理解:</div><div> <span style="color: rgb(188, 0, 88);">   </span><span style="color: rgb(227, 0, 0);">当在区块中用let命令声明的变量会形成一个块级作用域,在该作用域内对应着一个对象,收集着let声明的变量,而外部无法访问</span></div><div><span style="color: rgb(188, 0, 88);">    究其缘由应该是外部没有这个收集变量的对象的引用，而这个引用好比一把钥匙，没有钥匙便无法开门拿东西，而这个作用域就好比这个管理钥匙的人(规则)</span></div><div>    外人我还就不给了，只有自己的子代可以传承这个钥匙，这也就是为什么相互嵌套的函数内部或区块，子函数或子区块可以访问外部函数或外部区块中的变量(let和const声明),而非子函数则不能的其中一个解释。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>      let aa = 122;</div><div>        {</div><div>            let a = 13;</div><div>            var b = 12;</div><div>            const pi = 3.14;</div><div>            {</div><div>                console.log(a)</div><div>            }</div><div>        }</div><div>        function foo() {</div><div>            var c = 1233;</div><div>            {</div><div>                let d = 2;</div><div>            }</div><div>            console.log(aa)</div><div>            function bb() {</div><div>                console.log(d)</div><div>                console.log(c)</div><div>            }</div><div>        }</div><div>        foo();</div><div>        console.log(b)//12</div><div>        console.log(a)//error</div><div>        console.log(window.aa)//undefined</div><div>        //PS:无论在是全局范围内还是函数内部，只要把let声明的变量放在一个区块中--》类似{let a = 12},就会构成一个块级作用域,</div><div>        //该块级作用域下对应着一个对象 ，在该作用域下的变量会放到该对象内</div><div>        //并将那个对象的引用放到当前执行环境中的作用域链的顶端,一旦执行操作执行完该区块内的代码时,指向该作用域内部的那个对象引用会被释放</div><div>        //这也是为什么无法在区块以外访问到区块中的变量的原因了,也可以解释let--&gt;for循环内部的原理了。</div><div><span style="font-weight: bold;">        ----------------------------------------------------------------------------------------------------------------------------------------------------------</span></div><div>        这里的for循环等价于下面的代码,在引用阮一峰大神的一段话:</div><div>     <span style="font-size: 10pt;"> </span> <span style="font-size: 10pt; color: rgb(255, 0, 0);"> </span><font color="#FF0000" style="font-size: 10pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">上面代码中，变量</span><span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">i</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">是</span><span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">let</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">声明的，当前的</span><span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">i</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">只在本轮循环有效，所以每一次循环的</span><span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">i</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">其实都是一个新的变量,所以最后输出的是</span></font><span style="font-size: 10pt; color: rgb(255, 0, 0); font-family: Verdana, Arial;">3。</span></div><div><font color="#FF0000" style="font-size: 10pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">       你可能会问,如果每一轮循环的变量</span><span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">i</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">都是重新声明的,那它怎么知道上一轮循环的值,从而计算出本轮循环的值？</span></font></div><div><font color="#FF0000" style="font-size: 10pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">       这是因为 JavaScript 引擎内部会记住上一轮循环的值,初始化本轮的变量 </span><span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">i</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(255, 0, 0); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">时,就在上一轮循环的基础上进行计算。</span></font></div><div><font style="font-size: 10pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"><span style="font-size: 10pt; font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal; color: rgb(255, 0, 0);">    </span><span style="font-size: 10pt; font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal; color: rgb(255, 0, 0);"> </span> <span style="font-size: 10pt; font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal; color: rgb(227, 0, 0); font-weight: bold;"> </span><span style="font-size: 10pt; font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal; color: rgb(227, 0, 0); font-weight: bold;">注意</span><span style="font-size: 10pt; font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal; color: rgb(70, 70, 70);">:</span><span style="font-size: 10pt; font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal; color: rgb(70, 70, 70);">for循环中的括号相当于一个块级作用域，而内部的{}是子块级作用域，每次循环时都会形成一个新的子级块级作用域,</span></span></font></div><div><font style="font-size: 10pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; color: rgb(70, 70, 70); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">       该作用域下对应着一个对象，存储着let声明的变量，而函数内部的代码需要用到外部块级作用域下的变量，所以啊</span></span></font></div><div><font style="font-size: 10pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; color: rgb(70, 70, 70); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">       这里每次循环都会产生一个类型为block的对象，被保存在函数的[[scopes]]上，好比闭包的形成过程，这里就无须多言啦</span></span></font></div><div><font style="font-size: 10pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; color: rgb(70, 70, 70); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    </span><span style="font-size: 10pt; color: rgb(70, 70, 70); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   简单描述函数的[[scopes]],arr[0]保存的函数的[[scopes]]={0:GO,1:</span><span style="font-size: 10pt; color: rgb(147, 150, 0); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">{</span><span style="font-size: 10pt; color: rgb(70, 70, 70); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">type:'block',object:</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">{i = 0}</span><span style="font-size: 10pt; color: rgb(147, 150, 0); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span><span style="font-size: 10pt; color: rgb(70, 70, 70); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">},object的值就是对块级作用域下的对象的引用</span></span></font></div><div><font style="font-size: 10pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; color: rgb(70, 70, 70); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">       这里的_i可以理解为js引擎为了记住上一轮循环的值而重新声明的一个变量</span></span></font></div><div>        <img src="ES6中let深入理解_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>        <img src="ES6中let深入理解_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>        </div><div>        //而为什么区块内部嵌套的子区块内的代码可以访问?（引擎在执行代码并查找变量都是从当前执行环境中的作用域链去找的，都找不到就报错）</div><div>        //区块并不会形成一个全新的执行环境，所有这种相互嵌套的区块 内的代码其实都是在同一执行环境下的，访问变量时都是从同一执行环境下的作用域链查找</div><div>        // 而执行嵌套的子区块内的代码时，执行外部区块的操作并没有结束，所以在当前执行环境中的作用域链上,仍保留着外部区块形成的块级作用域下的对象的引用</div><div>        //所以说，内部区块可以访问外部区块。</div><div>    <img src="ES6中let深入理解_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><img src="ES6中let深入理解_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>        //在全局范围内let声明的变量不会作为window的属性名,而是独立存在一个全局作用域Script的下的一个对象内,在谷歌控制台是这么显示的</div><div>        只是证明它是独立存在的,我的理解是这个Script就是全局作用域的另一种表示,也就是说在全局作用域下对应着两个对象,一个window,一个script对象</div><div>        //换言之就是,在全局的执行环境中得作用域链中有两个引用{0:Script 1:GO}</div><div>        //这也是为什么foo函数初始化时foo.[[Scopes]] = {0:Script,1:GO}的原因了</div><div><br/></div><div><br/></div><div>        <span style="color: rgb(227, 0, 0); font-weight: bold;">接着说说let和const的其他规则吧，以上作为进阶的知识点，是自己个人理解，如有错误请指出，十分乐意接受反驳</span></div><div><br/></div><div>        1.我们知道var声明的变量会被提升到其他代码之前，值为undefined,其实这也是预编译搞得鬼啦，也就是说</div><div>      <span style="color: rgb(167, 69, 0);">  console.log(a);</span></div><div><span style="color: rgb(167, 69, 0);">        var a = 1;   //这里不报错，而是undefined</span></div><div><span style="color: rgb(167, 69, 0);">    </span><span style="color: rgb(167, 69, 0);"> </span>   为了解决这种不好得现象,es6提出的let命令不会在预编译阶段有这种变量提升现象，而是来了个暂时性死区(temporary dead zone)</div><div>        把在块级作用域内的let声明的变量放到一个TDZ区域去，凡是在TDZ内的变量，外面代码用了该变量名，就会报错，也就是说未声明就使用变量会报错</div><div>        只有当执行完那条给let声明的变量赋值操作后，这个变量就会从DTZ中移出,这时候使用该变量就不会报错了</div><div>        console.log(b);</div><div>        let b = 2; //报错</div><div>        let x = x//报错  TDZ = {x},然后赋值操作,</div><div>        ------------------------------</div><div>        let b = 2;//DTZ--&gt;{b},进行赋值操作后TDZ={},b出来，b = 2；</div><div>        conosle.log(b); //success</div><div><br/></div><div>        2. <span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="background-color: rgb(249, 242, 244); font-size: 10pt; color: rgb(199, 37, 78); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">let</span></span><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">不允许在相同作用域内，重复声明同一个变量。</span></div><div><br/></div><div><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">     3.<span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Verdana; font-variant-caps: normal; font-variant-ligatures: normal;">// ES6规定,块级作用域之中,函数声明语句的行为类似于let,在块级作用域之外不可引用。</span></span></div><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Verdana;">        // 但是浏览器的实现可以不遵守上面的规定,有自己的行为方式,如下:</span></div><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Verdana;">        // 1.允许在块级作用域内声明函数。</span></div><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Verdana;">        // 2.函数声明类似于var,即会提升到全局作用域或函数作用域的头部。</span></div><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Verdana;">        // 3.同时,函数声明还会提升到所在的块级作用域的头部。</span></div><div><img src="ES6中let深入理解_files/Image [4].png" type="image/png" data-filename="Image.png" style="font-family: Verdana; font-size: 11pt; color: rgb(51, 51, 51);"/></div><div><img src="ES6中let深入理解_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 12pt;">这里其实是在匿名函数发生预编译时,把在块级作用域内的函数声明的名字给放到了自身作用域下AO对象上,值为undefined</span></div><div><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">联想以下前面所讲的作用域链那块知识,这里的疑惑就可以迎刃而解了.</span></div><div><img src="ES6中let深入理解_files/Image [6].png" type="image/png" data-filename="Image.png" style="font-family: Verdana; font-size: 11pt; color: rgb(51, 51, 51);"/></div><div><span style="font-size: 12pt;">所以说啊,为了避免不得而知的bug,在块级作用域内应该不用函数声明,而是用函数的表达式的声明的方式</span></div><div><img src="ES6中let深入理解_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt;">二</span><span style="font-size: 14pt; color: rgb(227, 0, 0);">.const常量声明</span></div><div><span style="font-size: 12pt;">1.</span> <span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="background-color: rgb(249, 242, 244); font-size: 11pt; color: rgb(199, 37, 78); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">const</span></span><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">声明一个只读的常量。一旦声明,常量的值就不能改变。</span></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"><span style="font-size: 15.36px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2.</span> <span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="background-color: rgb(249, 242, 244); font-size: 11pt; color: rgb(199, 37, 78); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">const</span></span><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">声明的变量不得改变值,这意味着,</span><span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="background-color: rgb(249, 242, 244); font-size: 11pt; color: rgb(199, 37, 78); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">const</span></span><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">一旦声明变量,就必须立即初始化,不能留到以后赋值。</span></span></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"><span style="font-size: 15.36px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3.</span> <span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="background-color: rgb(249, 242, 244); font-size: 11pt; color: rgb(199, 37, 78); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">const</span></span><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">的作用域与</span><span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="background-color: rgb(249, 242, 244); font-size: 11pt; color: rgb(199, 37, 78); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">let</span></span><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">命令相同:只在声明所在的块级作用域内有效。</span></span></span></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"><span style="font-size: 15.36px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">4.</span> <font style="font-size: 11pt;"><span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(199, 37, 78); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">const</span></font><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">实际上保证的,</span><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">并不是变量的值不得改动,而是变量指向的那个内存地址所保存的数据不得改动.对于简单类型的数据(数值、字符串、布尔值)值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据(主要是对象和数组),变量指向的内存地址,保存的只是一个指向实际数据的指针,</span><span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="background-color: rgb(249, 242, 244); font-size: 11pt; color: rgb(199, 37, 78); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">const</span></span><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">只能保证这个指针是固定的(即总是指向另一个固定的地址),至于它指向的数据结构是不是可变的,就完全不能控制了。因此,将一个对象声明为常量必须非常小心。</span></span></span></span></div><div><img src="ES6中let深入理解_files/Image [8].png" type="image/png" data-filename="Image.png" style="font-family: Verdana; font-size: 11pt; color: rgb(51, 51, 51);"/></div><div><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">上面代码中,常量</span><span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="background-color: rgb(249, 242, 244); font-size: 11pt; color: rgb(199, 37, 78); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">foo</span></span><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">储存的是一个地址,这个地址指向一个对象。不可变的只是这个地址,即不能把</span><span style="background: rgb(249, 242, 244); border-radius: 2px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="background-color: rgb(249, 242, 244); font-size: 11pt; color: rgb(199, 37, 78); font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">foo</span></span><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">指向另一个地址,但对象本身是可变的,</span></div><div><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">所以依然可以为其添加新属性。</span></div><div><br/></div><div><span style="color: rgb(167, 69, 0);">    </span></div><div><br/></div><div><br/></div></span>
</div></body></html> 