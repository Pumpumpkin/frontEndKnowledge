<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script>
		//生成器Generator
		//用于生成迭代器
		//执行Generator函数会返回一个遍历器对象,返回的遍历器对象,可以依次遍历Generator函数内部的每一个状态。
		//必须调用遍历器对象的next方法,使得指针移向下一个状态。
		//每次调用next方法,内部指针就从函数头部或上一次停下来的地方开始执行,直到遇到下一个yield表达式(或return语句)为止。
		//换言之,Generator函数是分段执行的,yield表达式是暂停执行的标记,而next方法可以恢复执行。
		//-------------------------------------------------------------------------------------------------------
		//形式上,Generator 函数是一个普通函数,但是有两个特征。
		//1.function关键字与函数名之间有一个星号;
		//2.函数体内部使用yield表达式,定义不同的内部状态;		

		// yield表达式
		// 遍历器对象的next方法的运行逻辑如下。

		// (1)遇到yield表达式,就暂停执行后面的操作,并将紧跟在yield后面的那个表达式的值,作为返回的对象的value属性值。

		// (2)下一次调用next方法时,再继续往下执行,直到遇到下一个yield表达式。

		// (3)如果没有再遇到新的yield表达式,就一直运行到函数结束,直到return语句为止,并将return语句后面的表达式的值,作为返回的对象的value属性值。done变为true

		// (4)如果该函数没有return语句,则返回的对象的value属性值为undefined。done变为true

		/*
			yield表达式本身没有返回值,或者说总是返回undefined。
			next方法可以带一个参数,该参数就会被当作上一个yield表达式的返回值。
		*/
		/*
			注意:由于next方法的参数表示上一个yield表达式的返回值,所以在第一次使用next方法时,传递参数是无效的。
			V8引擎直接忽略第一次使用next方法时的参数,只有从第二次使用next方法开始,参数才是有效的。
			从语义上讲,第一个next方法用来启动遍历器对象,所以不用带有参数。
		*/
		function *createIterator() {
			var a = 1;
			var x = yield 1;
			console.log(x)//5,这里有值是因为调用next方法时指定了参数
			var y = (yield 2);
			console.log(y)//undefined
			yield 3 * 6 + x;
		}
		var i = createIterator();
		//只有调用next方法时,createIterator函数才会执行
		console.log(i.next())//1
		console.log(i.next(5))//2
		console.log(i.next())//23

		// yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。
		// (function(){
		// 	yield 2
		// }())//unexpected number

		//----------------------------------------------------------------------------------------
		// for...of循环可以自动遍历 Generator 函数时生成的Iterator对象,且此时不再需要调用next方法,或者说for of循环内部自动调用了next方法
		function *foo() {
			yield 1;
			yield 2;
			yield 3;
			yield 4;
			return 5;
		}
		for(let j of foo()){
			console.log(j)
		}//1 2 3 4
		/*
			上面代码使用for...of循环,依次显示4个yield表达式的值。
			注意,一旦next方法的返回对象的done属性为true,for...of循环就会中止,且不包含该返回对象,所以上面代码的return语句返回的5,不包括在for...of循环之中
		*/

		//--------------------------------------------------------------------------------------------------------
		// yield*表达式
		// 如果在Generator函数内部,调用另一个Generator函数,默认情况下是没有效果的。
		// function* f() {
		// 	yield 1;
		// 	foo();
		// }
		// for(let i of f()) {
		// 	console.log(i)
		// }// 1

		// 这个就需要用到yield*表达式,用来在一个Generator函数里面执行另一个Generator函数。
		function* f() {
			yield 0;
			yield* foo();
		}
		for(let i of f()) {
			console.log(i)
		}// 0 1 2 3 4 

		// 如果yield表达式后面跟的是一个可遍历的对象,需要在yield表达式后面加上星号,表明它返回的是一个遍历器对象。
		// 这被称为yield*表达式,yield*后面必须跟可遍历的对象,否则会报错。

		function *generate() {
			yield 1;
			var x = yield [0,0]
			var y = yield* [2,3,4];
			// 等价于for(let value of [2,3,4]){yield value}
			console.log(x,y)//undefined undefined
		}
		let ger = generate();
		console.log(ger.next())//{value:1,done:false}
		console.log(ger.next())//{value:[0,0],done:false}
		console.log(ger.next())//{value:2,done:false}
		for(let i of generate()) {
			console.log(i)
		}//1 [0,0] 2 3 4
		// 上面代码中,yield命令后面如果不加星号,表达式的值是整个数组,加了星号就表示表达式的值是数组的遍历器对象调用next方法后的value属性值
		// 等同于执行多次[2,3,4][Symbol.iterator]().next().value,将其值给到返回的对象的value属性,然后返回结果对象
		// yield*相当于部署了一个for of循环
		// 以上var y = yield* [2,3,4];代码可变为 for(let value of [2,3,4]){yield value}

	</script>
</body>
</html>