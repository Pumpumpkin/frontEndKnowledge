<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //ES6写法
      class myPromise {
        constructor(fn) {
          if (typeof fn !== "function") {
            throw TypeError(`Promise resolver ${fn} is not a function`);
          }
          this.value = undefined;
          this.status = "pending";
          //以下两个属性用来保存then函数中对应状态的回调函数,以便异步操作有结果后调用
          //因为,promise对象状态一直为pending,等待异步有结果后promise对象的状态才发生改变,然后执行对应then函数的回调函数
          //而由于js执行机制,then函数会先执行,执行完后异步函数才执行,这时由于promise对象状态没改变,所以then函数的回调函数不会执行,则then函数会返回一个pending的promise对象
          //等到异步操作有结果后,我们需要执行then函数中对应状态的回调函数,这时无法执行,所以我们要用属性在then函数执行完前先保存它的两个回调函数
          this.resolveCbArr = []; //用数组是把多个回调函数储存起来,避免覆盖现象的发生
          this.rejectCbArr = [];
          let resolve = data => {
            //来个定时器,异步处理回调函数
            setTimeout(() => {
              if (this.status === "pending") {
                // console.log(1)
                this.status = "resolved";
                this.value = data;
                //当promise对象的状态发生改变时:1.若this.resolveCB有值则执行对应的函数
                this.resolveCbArr.length &&
                this.resolveCbArr.forEach(fn => fn());
              }
            }, 0);
          };
          let reject = data => {
            setTimeout(() => {
              if (this.status === "pending") {
                this.status = "rejected";
                this.value = data;
                this.rejectCbArr.length && this.rejectCbArr.forEach(fn => fn());
              }
            }, 0);
          };
          fn(resolve, reject);
        }
        then(resolveFn, rejectFn) {
          if (this.status === "resolved") {
            let result = resolveFn(this.value);
            if (result instanceof myPromise) {
              return result;
            } else {
              return myPromise.resolve(result);
            }
          }
          if (this.status === "rejected") {
            rejectFn(this.value);
          }
          //这是难点
          if (this.status === "pending") {
            return new Promise((suc, err) => {
              //将then函数的两个参数保存在原promise对象上
              //这里的this指的是原来的promise对象,因为是在箭头函数中,也就是调用then方法的那个promise对象
              this.resolveCbArr.push(
                (resolveFn => {
                  return () => {
                    //若resolveFn返回的是一个promise对象,则直接调用该对象的then方法,根据该对象的状态来映射新返回的promise对象(then函数返回的对象)的状态
                    let result = resolveFn(this.value);
                    // console.log(result)
                    if (result instanceof myPromise) {
                      result.then(suc, err);
                      //result对象的状态的改变会执行对应的回调函数,则新返回的promise对象的状态会发生相应改变
                      //即result为resolved状态，则新返回的promise实例也为resolved状态,因为会触发suc函数的执行
                    } else {
                      //若resolveFn返回的不是一个promise对象,则默认将新返回的promise对象的状态变为'resolved'
                      suc(result);
                    }
                  };
                })(resolveFn)
              );
              this.rejectCbArr.push(
                (rejectFn => {
                  return () => {
                    let res = rejectFn(this.value);
                    if (res instanceof myPromise) {
                      res.then(suc, err);
                    } else {
                      suc(res);
                    }
                  };
                })(rejectFn)
              );
            });
          }
        }
        static resolve(data) {
          return new myPromise(resolve => resolve(data));
        }
        static reject(data) {
          return new myPromise(resolve => {}, reject => reject(data));
        }
      }
      // let p1 = new myPromise((resolve,reject) => {})
      // let pp1 = p1.then();
      // let promise = new Promise((suc, err) => {
      //   setTimeout(function() {
      //     err(13);
      //   }, 3000);
      // });
      let promise = new myPromise((suc, err) => {
        console.log(1);
        suc(1);
      });
      let newP = promise.then(
        suc => {
          console.log(2);
        },
        err => console.log(err)
      );
      console.log(3);
      //1 3 2
    </script>
  </body>
</html>
