### 网络中的协议是什么？
计算机与网络设备要进行相互通信，那么双方必须基于相同的方法。  
好比，你和外国人交流，那么双方都必须会说对方国家的语言，才能达到交流的目的。  
而不同的硬件、操作系统之间的通信等等，所有这一切都需要一种**规则**，而这种规则就叫**协议(protocol)**  
### HTTP协议
HTTP(Hyper Text Transfer Protocol => 超文本传输协议)，它是一个应用层上的协议，它规定了客户端与服务器端之间 发生通信的一系列流程，Web就是建立在HTTP协议上进行通信的，而HTTP协议是基于TCP/IP协议族的。 
### HTTP协议的构成
HTTP协议由请求报文和响应报文组成。  
#### 请求报文的组成
- 请求行：请求方法(类型)，请求的URI(请求的资源)，HTTP协议版本号
- 请求头：说明服务器要使用的附加信息，由键值对构成(Content-Type、Accept)
- 请求体：可以添加任意的其他数据
#### 响应报文的组成
- 响应行：HTTP协议版本号、数字状态码和原因短语(对状态码进行文本形式的解释)
- 响应首部字段(响应头)：说明客户端要使用的一些附加信息
- 响应主体：返回给客户端的文本信息
### HTTP协议的特点
- 不保存状态(无状态)协议：自身不对请求和响应之间的通信状态进行保存，即无记忆能力，比鱼的记忆都不如，哈哈
### HTTP常见的方法
- GET: 获取资源
- POST：传输资源
- PUT：上传文件或是更新资源
- DELETE: 删除资源
- OPTIONS: 询问服务器支持的方法
### GET和POST的区别
1. 相同点
    - 都可以发送数据，也都可以获取数据
    - 如果不基于RFC规范，二者没有区别，只是名字不一样
2. 不同点(基于RFC规范)
    - GET请求的数据是在URL上的，而URL是对外可见的，而POST是在请求主体中，相对安全
    - GET对数据长度有限制，因为发送数据时，会被添加到URL中，而URL长度是受限制的(最大长度是2048个字符)，而POST无限制
    - GET可收藏为书签，而POST不可以
    - GET历史参数会保留在浏览器历史中，POST不会
    - GET只允许ASCII字符，POST无限制，也允许二进制数据
    - GET编码类型为application/x-www-form-url，而post为encodedapplication/x-www-form-urlencoded或multipart/form-data，为二进制数据提供多重编码类型
    - GET后退/刷新无影响，POST数据会被重新提交
    - POST => 浏览器会先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok则返回数据，而GET请求 => 浏览器会把header和data一并发送出去，所以**GET产生一个TCP数据包，而POST产生两个**
### HTTP的状态码
HTTP的状态码被分为五大类。
#### 1xx 信息性状态码
表示请求已被接受，继续处理中
#### 2xx 成功状态码
- 200：OK，请求没有问题，实体的主体部分包含了所请求的资源，即资源到手
- 204：No Content，请求成功，但响应报文中没有包含实体的主体部分，常见用例是204作为PUT请求的结果返回，更新资源，而不更改向用户显示的页面的当前内容
- 206：Partial content，表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容，开始觉得这个状态码是稀客，不常见，直到我爬网易云歌曲数据时，才发现在进行音频文件数据的请求时，服务器会返回这个状态码，表示返回部分内容，可以实现大文件的断点续传
#### 3xx 重定向
重定向状态码就是告诉客户端使用替代位置来访问他们所感兴趣的资源。
- 301 永久性重定向，表示资源已被分配到了新的URL，响应的Location首部中包含该URL，以后使用该URL进行资源的访问
- 302 与301类似，不过客户端一个使用Location首部给出的URL来临时定位资源，将来的请求仍使用老的URL
- 304 表示资源未被修改，自从上次请求后，请求的网页没有改变，服务器返会该响应状态码，不会返回网页内容，所以可以利用浏览器的缓存机制来获取缓存资源，从而节省带宽开销
#### 4xx 客户端错误状态码
- 400 Bad Request，告诉客户端它发送了一个错误的请求
- 401 Unauthorized，发送的请求需要有通过HTTP认证的认证信息，才能获取相应的资源，比如登录淘宝网，必须要注册自己的账号，认证成功后才可进行购买东西等等操作
- 403 Forbidden，说明请求被服务器拒绝了，可能是没有权限或其他原因，但是服务器不想说明原因
- 404 Not Found，说明服务器上没有你所请求的URL，在我这儿找不到你要的资源
#### 5xx 服务器端错误
- 500 表示服务器正在执行请求时发生了错误，可能某段代码执行发生报错
- 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能，比如，使用了服务器不支持的请求方法时
- 503 Service Unavailable，说明服务器现在无法为请求提供服务，但将来可以，如：服务器暂时处于超负载或停机维护状态，无法处理请求
### HTTP的持久连接(HTTP1.1默认支持)
在HTTP1.0以及以前的版本，每进行完一次通信就要断开一次TCP连接，比如，发送请求一份包含多张图片的HTML文档，由于文档内需要请求图片，所以会进行大量的HTTP请求，如下图：  
![示例图](https://raw.githubusercontent.com/pumpkinduan/FigureBed/master/img/20200417121920.png)  
解决方法就是在HTTP1.1中出现了`Connection: keep-alive`模式，建立持久化连接
> 只要任意一端没有明确提出断开连接，则保持TCP的连接状态 ，可以很好的减少了TCP的重复连接断开次数，减轻了服务器的压力
### HTTP的管线化(HTTP1.1默认支持)
持久连接使得多数请求以管线化方式发送，这种技术可实现：**不同等待响应可直接发送下一个请求，可并发多个请求**
- 只有get和head请求可以进行管线化，pos有限制
- 初次创建连接时不应该启动管线化技术，服务器不一定支持