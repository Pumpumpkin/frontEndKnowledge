//os(操作系统)模块
//用来获取机器信息的
let os = require('os');
// console.log(os.cpus()) //机器当前cpu信息
// console.log(os.totalmem()) //机器的内存,返回字节大小
// console.log(os.networkInterfaces())
//Node中,有三种模块
//1.具名的核心模块,fs,http
//2.用户自己编写的文件模块,一个.js文件就是一个模块
//3.第三方模块,如 art-template

//Node中没有全局作用域,只有模块作用域
//使用require引入自己编写的js文件(子定义模块)时,相对路径中的./不能省略,不然node会把它当成核心模块来识别了
//node中一次只能执行一个js文件,若想执行多js文件.需要使用require加载需要执行的js文件,然后`执行



//重点: 
	//1.其实node.js(每个模块文件)都是在一个函数体内运行的,见第二点

console.log(arguments); //在cmd中可看到,打印一个类数组
console.log(arguments[0]); //exports对象
// console.log(arguments[1]); //require函数
// console.log(arguments[2]); //Module对象,内部有个属性为exports
console.log(arguments[3]); //__filename 表示当前执行文件的完整绝对路径
console.log(arguments[4]); //__dirname 表示当前执行文件所在目录的完整目录名
/*{
	'0': {}, 
	'1': {
		[Function: require]
		resolve: {
			[Function: resolve] paths: [Function: paths] },
		main: Module {
			id: '.',
			exports: {},
			parent: null,
			filename: 'E:\\南瓜童鞋的资料\\NodeJs\\Day1\\05_node_module\\05_node_modules.js',
			loaded: false,
			children: [],
			paths: [Array]
		},
		extensions: [Object: null prototype] { '.js': [Function], '.json': [Function], '.node': [Function] },
		cache: [Object: null prototype] {
			'E:\\南瓜童鞋的资料\\NodeJs\\Day1\\05_node_module\\05_node_modules.js': [Module]
		}
	},
	'2': Module {
		id: '.',
		exports: {},
		parent: null,
		filename: 'E:\\南瓜童鞋的资料\\NodeJs\\Day1\\05_node_module\\05_node_modules.js',
		loaded: false,
		children: [],
		paths: ['E:\\南瓜童鞋的资料\\NodeJs\\Day1\\05_node_module\\node_modules',
			'E:\\南瓜童鞋的资料\\NodeJs\\Day1\\node_modules',
			'E:\\南瓜童鞋的资料\\NodeJs\\node_modules',
			'E:\\南瓜童鞋的资料\\node_modules',
			'E:\\node_modules'
		]
	},
	'3': 'E:\\南瓜童鞋的资料\\NodeJs\\Day1\\05_node_module\\05_node_modules.js',
	'4': 'E:\\南瓜童鞋的资料\\NodeJs\\Day1\\05_node_module'
}*/

//2.module.exports == exports都指向同一个对象,而每个模块导出的接口对象都是这个modules.exports
/*
	function main (exports, require, module, __filename, __dirname) {
		//自己编写的js代码块...
		//require(path) 引入模块,该引入的模块会成为当前模块的子模块
		//也就是说在当前模块(也就是这个参数Module对象内)的children会包含该引入的模块
		return module.exports
	}

//模块文件就是这个函数的参数module

*/

/**
 * 3.来说说module.paths里面的路径都是什么意思
 * 有时候我们不引入核心模块,也不引入自己编写的模块,而是用别人写的第三方模块
 * 而这个第三方模块下载的目录名便是node_modules
 * 所以这个module.paths里的路径表示的就是 通过require引入第三方模块时的路径
 */

/**
 *最后,一定要清楚 module就代表着当前在nodejs中执行的模块(js文件)
 *而该js文件是在一个函数中运行的, （nodeJs中一次只能运行一个js文件）
 *这个函数被执行时,由内部机制给出了其中一个叫模块的对象,它包含了一系列信息,而这个对象被赋予了其中的一个名为module的参数
 *所以我们在js文件里可以访问到这个module对象,而这个对象还有个exports的属性,专门用来收集一些变量或方法,如module.exports.a = 1;
 *在函数的最后会return module.exports
 *
 * 该函数中还有四个变量我们可以之间用变量名访问到exports, require, __filename, __dirname
 * 其中exports === module.exports
 */