一个DAO文件对应一个表的操作
web文件夹 --> 负责接受web请求的,处理业务逻辑的,也就是装载了不同业务逻辑的代码
service文件夹 --> 接受服务的

一个方法解决一个请求,一个url对应一个接口,
我们约定(每个公司都会自己的约定),每个负责接收请求的文件必须导出一个储存了(url -> 方法)的map结构,
利用loader.js文件来对所有接收请求的文件进行解析，并收集它们导出的map结构中存储的数据,然后统一导出一个新的map


filter文件夹为一个拦截容器，里面装载了一些拦截器接口
拦截器接口的作用: 避免用户在不登录账号的情况下就访问到某些页面,进而通过一些事件进行后端接口的调用(数据请求),这样不安全也耗费性能,因此采取了这些措施,只对指定的有限的页面可以进行任意访问，对某些接口可以任意调用,如: 登录页面,登录时调用后端的数据请求接口

如何做到的呢? 

这里采用了cookie机制,也就是每次用户登录成功后，后端都会向浏览器端写入一个cookie,该cookie唯一，浏览器若存在该cookie，则表示用户登录成功，在成功下可以访问原先其他被限制的页面

否则不允许访问其他页面，就算知道了也页面的url也会被重定向到指定的登录页面进行登录操作

filter_loader:
    用于加载所有拦截器接口,将其收集起来,
    统一放到index.js这个主程序下运行,类似loader.js