<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<style>
    * {
        margin: 0;
        padding: 0;
    }

    .box {
        width: 300px;
        height: 300px;
        background-color: red;
        margin: 100px auto;
    }
</style>

<body>
    <div class="box"></div>
    <script>
        /*
        节流throttle:
            当连续触发事件时，保证在指定的时间间隔内只执行一次事件处理函数
            例如：指定延迟时间1s, 1s内连续调用10次或更多,不会执行,当1s过后执行一次回调函数，2s后执行一次...
        */
        // window.onresize = function() {
        //     console.log('change')
        // }
        window.onresize = throttle(function () { console.log('change') })
        function throttle(handle, delay) {
            var timerId = null;
            let flag = true;
            return function () {
                if (!flag) return;
                flag = false;
                let self = this;//DOM元素
                let args = arguments;//事件对象
                timerId && clearTimeout(timerId);
                timerId = setTimeout(function () {
                    handle.apply(self, args);
                    flag = true;
                }, delay || 5000);
            }
        }
        
        // function throttle(delay, handler) {//时间戳,开始触发事件会立即执行,不过可能最后一次触发事件不会执行
        //     var lastTime = 0;
        //     return function() {
        //         var nowTime = Date.now();
        //         if ( nowTime - lastTime >= delay ) {
        //             handler.apply(this, arguments);
        //             lastTime = nowTime;
        //         }
        //     }
        // }

        // function throttle(delay, handler) {//定时器,开始触发事件不会立即执行,延迟,不过最后一次触发事件会延迟在执行
        //     var timer = null;
        //     return function() {
        //         var arg = arguments;
        //         var self = this;
        //         if ( !timer ) {
        //             timer = setTimeout(function() {
        //                 handler.apply(self, arg);
        //                 timer = null;
        //             }, delay);
        //         }
        //     }
        // }

        //结合时间戳与定时器实现节流:开始触发事件会立即执行,最后一次触发事件也会执行,不过是延迟执行
        // function throttle(delay, handler) {
        //     var timer = null;
        //     var lastTime = 0;
        //     return function () {
        //         var arg = arguments;
        //         var self = this;
        //         var nowTime = Date.now();
        //         clearTimeout(timer)
        //         if (nowTime - lastTime >= delay) {//第一次立即执行
        //             handler.apply(self, arg);
        //             lastTime = nowTime;
        //         } else {
        //             timer = setTimeout(function () {
        //                 handler.apply(self, arg);
        //             }, delay);
        //         }
        //     }
        // }
    </script>
</body>

</html>