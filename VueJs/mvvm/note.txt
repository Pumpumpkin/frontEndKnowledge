1.什么是虚拟DOM: 一句话 --> 用来描述真实DOM结构的一种对象表示法
2.模板渲染原理:
    2.1: 定义一种模板语法(双大括号语法{{}})将data中的属性当成变量一样包裹起来在HTML中直接使用
    2.2: 利用一个可以解析模板语法的函数来解析HTML中模板
    2.3: 利用一个render函数将解析完后的模板变量与data中的属性名挨个对应,将变量名替换为data中对应的属性值
    2.4: 最后利用根结点的innerHTML重新渲染整个页面
    2.5: 上述过程太麻烦,每次变动部分数据都会引起视图的全部渲染,耗费性能
    2.6: 所以我们应该利用虚拟DOM来实现数据的变动只会渲染对应的视图部分,而不会每次引起整个视图的重新渲染    

3.响应式数据原理:
    如何实现当data中的某个属性的值发生改变时,HTML中用到的相应模板变量的值也会发生改变呢？
    var data = {name: 'pumpkin'}   <div>{{name}}</div> --->render后--> <div>pumpkin</div>
    当data.name = 'Lebran'时, 重新render<div>{{name}}</div>区域 --> <div>Lebran</div>

    3.1: 首先利用Object.defineProperty(targetObj, attr, descriptor)对data中的每个属性进行set和get的重写
    3.2: 当我们修改某个data中的属性的值时,就会触发当前属性的set函数的执行,辣么我们就在set中调用render函数进行重新渲染
    3.3: 实现局部的视图更新,也就是改变data中的某个属性的值,只会重新渲染HTML中用到该属性对应的模板变量所在的文本结点的值
    3.4: 我们需要建立一种映射关系,将模板变量与其所属的文本结点建立一对多的关系,模板变量一改变,其所属的文本结点的值全部改变
    3.5: 那么如何建立这种映射关系呢？给每个mvvm实例对象一个mapping属性用来保存map结构
        3.5.1: 首先获取一个根结点作为入口,将该根结点保存到一个对象(称为vnode)中去
               该对象中声明node,type,value三个属性分别表示DOM中的结点对象,节点类型,和节点的值,还有一个children保存其子虚拟节点

        3.5.2: 然后遍历其下的所有子节点,参照步骤3.5.1每遍历一个节点构建出一个vnode

        3.5.3：最后得到一个完整的虚拟DOM树形结构,用对象来表示该真实的DOM结构

        3.5.4: 我们在构建虚拟DOM时,由于会遍历真实的DOM,且过程中会进行判断是否为文本节点,
               辣么我们可以在该步骤中对文本节点的值进行模板解析,要是解析出了模板(如:{{name}}),就将该模板与其所属的文本节点拿出分别作为mapping中的key和value

        3.5.5: 由于同一个模板可以在不同的文本节点中使用,所以模板与文本节点的关系为一对多,所以我们利用一个数组将一个模板对应的所有文本节点储存起来,然后再储存到map结构中去

        3.5.6: 最后在实现渲染函数时,取出map所有的key,在对key进行遍历(key即为模板变量),
               只要data中变化的属性与key相同,则将key对应的所有文本节点的nodeValue的值进行更改,即可实现视图的局部渲染

4.什么是依赖收集? 这里只对data中的属性进行了依赖收集
    4.1: 将模板中依赖data中的属性全部收集起来
    4.2: 为 什么需要做依赖收集?
       4.2.1: 当data中的属性没有在模板中使用,而我们改变了这个data中的属性值,就会触发set函数的执行,
              而我们上面在set函数中做了劫持,进行了render函数执行,这样每次改变就会重新渲染,显然不是我们想要的
              所以我们将实际模板中依赖data中的属性全部收集起来,只有依赖项发生改变才会重新渲染
    4.3: 如何实现依赖收集呢?
              PS:(vue官网):
                     每个组件实例都对应一个 watcher 实例,
                     它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。
                     之后当依赖项的 setter 触发时,会通知 watcher,从而使它关联的组件重新渲染。
              a.定义一个Dep作为依赖收集类,其内部有个subs专门用来收集依赖项,这个收集类在set函数中进行劫持,
                可以得到data中的哪个属性变动了,然后利用notify通知对应的watcher
                收集依赖项的数据结构利用了map,每个data属性(这里指的就是依赖项)对应一个watcher实例,这里的watcher实例都是一样的,是全局vue实例下对应的那一个

              b.此外得要有一个观察类Watcher,与所有依赖项进行关联,当依赖项变动就触发一个update函数进行视图的重新渲染操作

              c.在notify函数中传递了一个属性参数的目的是 通知该属性对应的watcher进行视图的重新渲染,而不用对所有watcher实例执行操作